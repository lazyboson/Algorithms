/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author lazyboson
 */
 
#include <iostream>
#include <fstream>
 
#include <iostream>
#include <vector>
#include <stack>
 
const int maxN = 2e5 + 5;
typedef long long ll;
 
std::vector<int> adj[maxN], trans_adj[maxN], adj_scc[maxN];
ll dp[maxN], y[maxN];
 
class CoinCollector {
public:
    void dfs(int i, std::vector<bool> &visited, std::stack<int> &st) {
        if (visited[i])
            return;
        visited[i] = true;
        for (auto const &u: adj[i]) {
            dfs(u, visited, st);
        }
        st.push(i);
    }
 
    void dfs2(int curr, std::vector<bool> &visited, std::vector<int> &curr_set) {
        if (visited[curr])
            return;
        visited[curr] = true;
        curr_set.push_back(curr);
        for (auto const &u: trans_adj[curr]) {
            dfs2(u, visited, curr_set);
        }
    }
 
    void dfs3(int start, std::vector<bool> &visited) {
        if (visited[start])
            return;
        visited[start] = true;
        for (auto const &u: adj_scc[start]) {
            dfs3(u, visited);
            dp[start] = std::max(dp[start], dp[u]);
        }
        dp[start] += y[start];
    }
 
    void solve(std::istream &in, std::ostream &out) {
        int n, m;
        in >> n >> m;
        std::vector<int> coins(n + 1);
        for (int i = 1; i <= n; ++i) {
            in >> coins[i];
        }
 
        for (int i = 0, src, dest; i < m; ++i) {
            in >> src >> dest;
            adj[src].push_back(dest);
        }
        std::stack<int> st;
        std::vector<bool> visited(n + 1, false);
        for (int i = 1; i <= n; i++) {
            if (!visited[i])
                dfs(i, visited, st);
        }
        for (int i = 1; i <= n; ++i) {
            visited[i] = false;
            for (auto const &u: adj[i]) {
                trans_adj[u].push_back(i);
            }
        }
        std::vector<int> reps(n + 1);
        std::fill(y + 1, y + n + 1, 0);
        while (!st.empty()) {
            auto curr = st.top();
            st.pop();
            std::vector<int> components;
            if (!visited[curr]) {
                dfs2(curr, visited, components);
                int leader = components.front();
                for (auto const &c: components) {
                    reps[c] = leader;
                    y[leader] += coins[c];
                }
            }
        }
        for (int i = 1; i <= n; i++) {
            for (auto const &u: adj[i]) {
                int leader_u = reps[u];
                int leader_v = reps[i];
                if (leader_u != leader_v) {
                    adj_scc[leader_v].push_back(leader_u);
                }
            }
        }
        ll ans = 0;
        std::fill(visited.begin(), visited.end(), false);
        for (int i = 1; i <= n; ++i) {
            if (reps[i] == i && !visited[i]) {
                dfs3(i, visited), ans = std::max(dp[i], ans);
            }
        }
        out << ans << std::endl;
    }
};
 
int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(0);
    CoinCollector solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}
