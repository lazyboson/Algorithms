/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author lazyboson
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <vector>
#include <queue>

#define MAXIMUM 1e18+5
typedef long long ll;

class ShortestRoutesI {
public:
    void dijikstras(ll start, ll *distance, std::vector<std::pair<ll, ll>> adj[], bool *visited) {
        distance[start] = 0;
        std::priority_queue<std::pair<ll, ll>> queue;
        queue.push({0, start});
        while (!queue.empty()) {
            ll a = queue.top().second;
            queue.pop();
            if (visited[a]) {
                continue;
            }
            visited[a] = true;
            for (auto u: adj[a]) {
                ll b = u.first, w = u.second;
                if (distance[a] + w < distance[b]) {
                    distance[b] = distance[a] + w;
                    queue.push({-distance[b], b});
                    //predecessors[b] = a;
                }
            }
        }
    }

    void solve(std::istream &in, std::ostream &out) {
        ll n, m;
        in >> n >> m;
        std::vector<std::pair<ll, ll>> adj[n + 1];
        for (int i = 0; i < m; ++i) {
            ll src, dest, w;
            in >> src >> dest >> w;
            adj[src].push_back({dest, w});
        }
        ll distance[n + 1];
        for (int i = 0; i < n + 1; ++i) {
            distance[i] = MAXIMUM;
        }
        bool visited[n + 1];
        for (int i = 0; i < n + 1; ++i) {
            visited[i] = false;
        }
        dijikstras(1, distance, adj, visited);
        for (int i = 1; i < n + 1; ++i) {
            out << distance[i] << " ";
        }
        out << "\n";
    }
};

int main() {
    ShortestRoutesI solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}