/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author lazyboson
 */
 
#include <bits/stdc++.h>
 
using namespace std;
 
string direction = "URDL";
char grid[1000][1000];
int visited[1000][1000];
int path[1000][1000];
 
class Labyrinth {
public:
    void solve(std::istream &in, std::ostream &out) {
        int row, col;
        in >> row >> col;
        pair<int, int> start, end;
        for (int i = 0; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                in >> grid[i][j];
                if (grid[i][j] == 'A')
                    start = make_pair(i, j);
                else if (grid[i][j] == 'B')
                    end = make_pair(i, j);
            }
        }
 
        queue<pair<int, int>> q;
        q.push(start);
        visited[start.first][start.second] = true;
        int dx[] = {-1, 0, 1, 0};
        int dy[] = {0, 1, 0, -1};
        while (!q.empty()) {
            auto curr_node = q.front();
            q.pop();
            for (int i = 0; i < 4; ++i) {
                int presentX = dx[i] + curr_node.first;
                int presentY = dy[i] + curr_node.second;
                if (presentX < 0 || presentX >= row || presentY < 0 || presentY >= col ||
                    grid[presentX][presentY] == '#'
                    || visited[presentX][presentY])
                    continue;
                visited[presentX][presentY] = true;
                path[presentX][presentY] = i;
                q.push(make_pair(presentX, presentY));
            }
        }
 
        if (!visited[end.first][end.second])
            out << "NO\n";
        else {
            out << "YES\n";
            vector<int> steps;
            while (end != start) {
                int p = path[end.first][end.second];
                steps.push_back(p);
                end = make_pair(end.first - dx[p], end.second - dy[p]);
            }
            reverse(steps.begin(), steps.end());
            out << steps.size() << endl;
            for (char c: steps) {
                out << direction[c];
            }
            out << "\n";
        }
 
    }
};
 
 
int main() {
    ios_base::sync_with_stdio(0);
    Labyrinth solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}
